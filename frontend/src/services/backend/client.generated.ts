//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.20.0.0 (NJsonSchema v10.9.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

export class ClientConfiguration {
  constructor(public accessToken: string) {}
}

export class ClientBase {
  constructor(private clientConfiguration: ClientConfiguration) {}
  private cacheableResponse = false;
  private cacheStrategy: "CacheFirst" | "NetworkFirst" = "NetworkFirst";
  private cacheAllowStatuses: number[] = [200];
  private cacheableOptions: RequestInit = null;
  private responseCallbackMap: Record<
    number,
    (response: Response) => void | Promise<void>
  > = null;
  private signal: AbortSignal = null;
  private customHeaders: Record<string, string> = {};

  public setCacheableResponse(
    cacheStrategy: ClientBase["cacheStrategy"] = "NetworkFirst",
    cacheAllowStatuses: ClientBase["cacheAllowStatuses"] = [200]
  ) {
    this.cacheableResponse = true;
    this.cacheStrategy = cacheStrategy;
    this.cacheAllowStatuses = cacheAllowStatuses;
  }

  public setStatusCallbackMap(
    responseCallbackMap: ClientBase["responseCallbackMap"]
  ) {
    this.responseCallbackMap = responseCallbackMap;
  }

  public setAbortSignal(signal: AbortSignal) {
    this.signal = signal;
  }

  public addCustomHeader(key: string, value: string) {
    this.customHeaders[key] = value;
  }

  protected async transformOptions(options: RequestInit): Promise<RequestInit> {
    if (this.signal != null) options.signal = this.signal;

    if (options.headers) {
      Object.entries(this.customHeaders).forEach(([key, value]) => {
        (options.headers as Record<string, string>)[key] = value;
      });
    } else {
      options.headers = this.customHeaders;
    }

    if (this.clientConfiguration.accessToken) {
      (options.headers as Record<string, string>)["Authorization"] =
        "Bearer " + this.clientConfiguration.accessToken;
    }

    if (this.cacheableResponse) {
      this.cacheableOptions = options;
    }

    return options;
  }

  protected async transformResult(
    url: string,
    networkResponse: Response,
    clientProcessCallback: (response: Response) => Promise<any>
  ) {
    const response = await this.checkCache(url, networkResponse);
    const hasBeenHandled = await this.checkStatusCallback(response);

    if (hasBeenHandled !== null) {
      return hasBeenHandled;
    }
    return await clientProcessCallback(response);
  }

  private async putToCache(
    request: Request,
    response: Response
  ): Promise<Response> {
    const cache = await caches.open("nswagts.v1");
    const cloned = response.clone();
    await cache.put(request, response);

    return cloned;
  }

  private async checkCache(url: string, networkResponse: Response) {
    let response: Response = networkResponse;
    if (!process.browser || !this.cacheableResponse) {
      return response;
    }
    console.debug("NswagTs transformResult cacheableResponse executing...");

    const request = new Request(url, this.cacheableOptions);

    const cacheResponse = await caches.match(request);

    const networkOk = this.cacheAllowStatuses.includes(
      networkResponse?.status ?? 0
    );
    const cacheOk = this.cacheAllowStatuses.includes(
      cacheResponse?.status ?? 0
    );

    if (this.cacheStrategy === "CacheFirst") {
      if (cacheOk) {
        console.debug(
          "NswagTs transformResult cacheableResponse cache first using cache",
          cacheResponse
        );
        response = cacheResponse;
      } else {
        console.debug(
          "NswagTs transformResult cacheableResponse cache first using network",
          networkResponse
        );
        response = networkOk
          ? await this.putToCache(request, networkResponse)
          : networkResponse;
      }
    } else if (this.cacheStrategy === "NetworkFirst") {
      if (networkOk) {
        console.debug(
          "NswagTs transformResult cacheableResponse network first using network ok",
          networkResponse
        );
        response = await this.putToCache(request, networkResponse);
      } else if (cacheOk) {
        console.debug(
          "NswagTs transformResult cacheableResponse network first using cache",
          cacheResponse
        );
        response = cacheResponse;
      } else {
        console.debug(
          "NswagTs transformResult cacheableResponse network first using network failure",
          networkResponse
        );
        response = networkResponse;
      }
    }
    this.cacheableResponse = false;
  }

  private async checkStatusCallback(response: Response): Promise<unknown> {
    if (this.responseCallbackMap == null) return null;

    if (
      Object.keys(this.responseCallbackMap).includes(response.status.toString())
    ) {
      const db = this.responseCallbackMap[response.status];

      const result = await db(response);

      return result;
    }

    return null;
  }
}

export class ApiFetchClient extends ClientBase {
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(configuration: ClientConfiguration, baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        super(configuration);
        this.http = http ? http : window as any;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "";
    }

    index_Hello(name?: string | undefined, signal?: AbortSignal | undefined): Promise<string> {
        let url_ = this.baseUrl + "/api/Index?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processIndex_Hello(_response));
        });
    }

    protected processIndex_Hello(response: Response): Promise<string> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<string>(null as any);
    }

    tasks_CreateTaskList(command: CreateTaskListCommand, signal?: AbortSignal | undefined): Promise<TaskListDto> {
        let url_ = this.baseUrl + "/api/Tasks/lists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_CreateTaskList(_response));
        });
    }

    protected processTasks_CreateTaskList(response: Response): Promise<TaskListDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto>(null as any);
    }

    tasks_GetUserTaskLists(signal?: AbortSignal | undefined): Promise<TaskListDto[]> {
        let url_ = this.baseUrl + "/api/Tasks/lists";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetUserTaskLists(_response));
        });
    }

    protected processTasks_GetUserTaskLists(response: Response): Promise<TaskListDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto[]>(null as any);
    }

    tasks_GetTask(id: number, signal?: AbortSignal | undefined): Promise<TaskDto> {
        let url_ = this.baseUrl + "/api/Tasks/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetTask(_response));
        });
    }

    protected processTasks_GetTask(response: Response): Promise<TaskDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto>(null as any);
    }

    tasks_GetTaskList(id: number, signal?: AbortSignal | undefined): Promise<TaskListDto> {
        let url_ = this.baseUrl + "/api/Tasks/lists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetTaskList(_response));
        });
    }

    protected processTasks_GetTaskList(response: Response): Promise<TaskListDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto>(null as any);
    }

    tasks_UpdateTaskList(id: number, command: UpdateTaskListCommand, signal?: AbortSignal | undefined): Promise<TaskListDto> {
        let url_ = this.baseUrl + "/api/Tasks/lists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_UpdateTaskList(_response));
        });
    }

    protected processTasks_UpdateTaskList(response: Response): Promise<TaskListDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskListDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskListDto>(null as any);
    }

    tasks_ShareTaskList(id: number, userIdsToShare: number[], signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Tasks/lists/{id}/share";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userIdsToShare);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_ShareTaskList(_response));
        });
    }

    protected processTasks_ShareTaskList(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    tasks_CreateTask(command: CreateTaskCommand, signal?: AbortSignal | undefined): Promise<TaskDto> {
        let url_ = this.baseUrl + "/api/Tasks/tasks";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_CreateTask(_response));
        });
    }

    protected processTasks_CreateTask(response: Response): Promise<TaskDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto>(null as any);
    }

    tasks_UpdateTaskStatus(id: number, command: UpdateTaskStatusCommand, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Tasks/{id}/status";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_UpdateTaskStatus(_response));
        });
    }

    protected processTasks_UpdateTaskStatus(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    tasks_GetTaskSummary(taskListId: number, signal?: AbortSignal | undefined): Promise<TaskSummaryDto> {
        let url_ = this.baseUrl + "/api/Tasks/lists/{taskListId}/summary";
        if (taskListId === undefined || taskListId === null)
            throw new Error("The parameter 'taskListId' must be defined.");
        url_ = url_.replace("{taskListId}", encodeURIComponent("" + taskListId));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetTaskSummary(_response));
        });
    }

    protected processTasks_GetTaskSummary(response: Response): Promise<TaskSummaryDto> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskSummaryDto;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskSummaryDto>(null as any);
    }

    tasks_ClearCompletedTasks(signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Tasks/clear-completed";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_ClearCompletedTasks(_response));
        });
    }

    protected processTasks_ClearCompletedTasks(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    tasks_GetTasksByState(isCompleted?: boolean | null | undefined, isFavorite?: boolean | null | undefined, sortBy?: string | null | undefined, sortDescending?: boolean | undefined, taskListId?: number | null | undefined, signal?: AbortSignal | undefined): Promise<TaskDto[]> {
        let url_ = this.baseUrl + "/api/Tasks/filter?";
        if (isCompleted !== undefined && isCompleted !== null)
            url_ += "IsCompleted=" + encodeURIComponent("" + isCompleted) + "&";
        if (isFavorite !== undefined && isFavorite !== null)
            url_ += "IsFavorite=" + encodeURIComponent("" + isFavorite) + "&";
        if (sortBy !== undefined && sortBy !== null)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (sortDescending === null)
            throw new Error("The parameter 'sortDescending' cannot be null.");
        else if (sortDescending !== undefined)
            url_ += "SortDescending=" + encodeURIComponent("" + sortDescending) + "&";
        if (taskListId !== undefined && taskListId !== null)
            url_ += "TaskListId=" + encodeURIComponent("" + taskListId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetTasksByState(_response));
        });
    }

    protected processTasks_GetTasksByState(response: Response): Promise<TaskDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TaskDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TaskDto[]>(null as any);
    }

    tasks_UpdateTaskDetails(id: number, command: UpdateTaskDetailsCommand, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Tasks/{id}/details";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_UpdateTaskDetails(_response));
        });
    }

    protected processTasks_UpdateTaskDetails(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    tasks_GetUsersByTaskListAssociation(id: number, isAssociated?: boolean | undefined, signal?: AbortSignal | undefined): Promise<UserDto[]> {
        let url_ = this.baseUrl + "/api/Tasks/lists/{id}/users?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (isAssociated === null)
            throw new Error("The parameter 'isAssociated' cannot be null.");
        else if (isAssociated !== undefined)
            url_ += "isAssociated=" + encodeURIComponent("" + isAssociated) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTasks_GetUsersByTaskListAssociation(_response));
        });
    }

    protected processTasks_GetUsersByTaskListAssociation(response: Response): Promise<UserDto[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserDto[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<UserDto[]>(null as any);
    }

    templateExampleCustomer_Create(command: CreateTemplateExampleCustomerCommand, signal?: AbortSignal | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/TemplateExampleCustomer/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleCustomer_Create(_response));
        });
    }

    protected processTemplateExampleCustomer_Create(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    templateExampleCustomer_Update(command: UpdateTemplateExampleCustomerCommand, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TemplateExampleCustomer/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleCustomer_Update(_response));
        });
    }

    protected processTemplateExampleCustomer_Update(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    templateExampleCustomer_Get(id?: number | undefined, signal?: AbortSignal | undefined): Promise<TemplateExampleDetailedCustomerDTO> {
        let url_ = this.baseUrl + "/api/TemplateExampleCustomer/Get?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleCustomer_Get(_response));
        });
    }

    protected processTemplateExampleCustomer_Get(response: Response): Promise<TemplateExampleDetailedCustomerDTO> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TemplateExampleDetailedCustomerDTO;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateExampleDetailedCustomerDTO>(null as any);
    }

    templateExampleCustomer_GetAll(query?: GetTemplateExampleCustomersQuery | undefined, signal?: AbortSignal | undefined): Promise<TemplateExampleSimpleCustomerDTO[]> {
        let url_ = this.baseUrl + "/api/TemplateExampleCustomer/GetAll?";
        if (query === null)
            throw new Error("The parameter 'query' cannot be null.");
        else if (query !== undefined)
            url_ += "query=" + encodeURIComponent("" + query) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleCustomer_GetAll(_response));
        });
    }

    protected processTemplateExampleCustomer_GetAll(response: Response): Promise<TemplateExampleSimpleCustomerDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TemplateExampleSimpleCustomerDTO[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateExampleSimpleCustomerDTO[]>(null as any);
    }

    templateExampleItem_Create(command: CreateTemplateExampleItemCommand, signal?: AbortSignal | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/TemplateExampleItem/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleItem_Create(_response));
        });
    }

    protected processTemplateExampleItem_Create(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    templateExampleItem_Update(command: UpdateTemplateExampleItemsStatusCommand, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TemplateExampleItem/Update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "PUT",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleItem_Update(_response));
        });
    }

    protected processTemplateExampleItem_Update(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    templateExampleItem_Get(status?: TemplateExampleItemStatus | null | undefined, signal?: AbortSignal | undefined): Promise<TemplateExampleItemDTO[]> {
        let url_ = this.baseUrl + "/api/TemplateExampleItem/Get?";
        if (status !== undefined && status !== null)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "GET",
            signal,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleItem_Get(_response));
        });
    }

    protected processTemplateExampleItem_Get(response: Response): Promise<TemplateExampleItemDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TemplateExampleItemDTO[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateExampleItemDTO[]>(null as any);
    }

    templateExampleOrder_Create(command: CreateTemplateExampleOrderCommand, signal?: AbortSignal | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/TemplateExampleOrder/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleOrder_Create(_response));
        });
    }

    protected processTemplateExampleOrder_Create(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    templateExampleOrder_DeleteByCustomerId(shippingAddress_Street?: string | undefined, shippingAddress_City?: string | undefined, shippingAddress_State?: string | undefined, shippingAddress_Country?: string | undefined, shippingAddress_ZipCode?: string | undefined, customerId?: number | undefined, items?: TemplateExampleOrderItemDTO[] | undefined, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/TemplateExampleOrder/DeleteByCustomerId?";
        if (shippingAddress_Street === null)
            throw new Error("The parameter 'shippingAddress_Street' cannot be null.");
        else if (shippingAddress_Street !== undefined)
            url_ += "ShippingAddress.Street=" + encodeURIComponent("" + shippingAddress_Street) + "&";
        if (shippingAddress_City === null)
            throw new Error("The parameter 'shippingAddress_City' cannot be null.");
        else if (shippingAddress_City !== undefined)
            url_ += "ShippingAddress.City=" + encodeURIComponent("" + shippingAddress_City) + "&";
        if (shippingAddress_State === null)
            throw new Error("The parameter 'shippingAddress_State' cannot be null.");
        else if (shippingAddress_State !== undefined)
            url_ += "ShippingAddress.State=" + encodeURIComponent("" + shippingAddress_State) + "&";
        if (shippingAddress_Country === null)
            throw new Error("The parameter 'shippingAddress_Country' cannot be null.");
        else if (shippingAddress_Country !== undefined)
            url_ += "ShippingAddress.Country=" + encodeURIComponent("" + shippingAddress_Country) + "&";
        if (shippingAddress_ZipCode === null)
            throw new Error("The parameter 'shippingAddress_ZipCode' cannot be null.");
        else if (shippingAddress_ZipCode !== undefined)
            url_ += "ShippingAddress.ZipCode=" + encodeURIComponent("" + shippingAddress_ZipCode) + "&";
        if (customerId === null)
            throw new Error("The parameter 'customerId' cannot be null.");
        else if (customerId !== undefined)
            url_ += "CustomerId=" + encodeURIComponent("" + customerId) + "&";
        if (items === null)
            throw new Error("The parameter 'items' cannot be null.");
        else if (items !== undefined)
            items && items.forEach((item, index) => {
                for (let attr in item)
        			if (item.hasOwnProperty(attr)) {
        				url_ += "Items[" + index + "]." + attr + "=" + encodeURIComponent("" + (item as any)[attr]) + "&";
        			}
            });
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleOrder_DeleteByCustomerId(_response));
        });
    }

    protected processTemplateExampleOrder_DeleteByCustomerId(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }

    templateExampleOrder_Get(query: GetTemplateExampleOrdersQuery, signal?: AbortSignal | undefined): Promise<TemplateExampleOrderDTO[]> {
        let url_ = this.baseUrl + "/api/TemplateExampleOrder/Get";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "GET",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processTemplateExampleOrder_Get(_response));
        });
    }

    protected processTemplateExampleOrder_Get(response: Response): Promise<TemplateExampleOrderDTO[]> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TemplateExampleOrderDTO[];
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<TemplateExampleOrderDTO[]>(null as any);
    }

    users_Register(command: RegisterUserCommand, signal?: AbortSignal | undefined): Promise<number> {
        let url_ = this.baseUrl + "/api/Users/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUsers_Register(_response));
        });
    }

    protected processUsers_Register(response: Response): Promise<number> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as number;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<number>(null as any);
    }

    users_Login(query: LoginUserQuery, signal?: AbortSignal | undefined): Promise<LoginResult> {
        let url_ = this.baseUrl + "/api/Users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(query);

        let options_: RequestInit = {
            body: content_,
            method: "POST",
            signal,
            headers: {
                "Content-Type": "application/json",
                "Accept": "application/json"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUsers_Login(_response));
        });
    }

    protected processUsers_Login(response: Response): Promise<LoginResult> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200) {
            return response.text().then((_responseText) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LoginResult;
            return result200;
            });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<LoginResult>(null as any);
    }

    users_DeleteUser(id: number, signal?: AbortSignal | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/api/Users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_: RequestInit = {
            method: "DELETE",
            signal,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.transformOptions(options_).then(transformedOptions_ => {
            return this.http.fetch(url_, transformedOptions_);
        }).then((_response: Response) => {
            return this.transformResult(url_, _response, (_response: Response) => this.processUsers_DeleteUser(_response));
        });
    }

    protected processUsers_DeleteUser(response: Response): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {}; if (response.headers && response.headers.forEach) { response.headers.forEach((v: any, k: any) => _headers[k] = v); };
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return response.blob().then(blob => { return { fileName: fileName, data: blob, status: status, headers: _headers }; });
        } else if (status !== 200 && status !== 204) {
            return response.text().then((_responseText) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Promise.resolve<FileResponse>(null as any);
    }
}

export interface TaskListDto {
    id?: number;
    name?: string;
    description?: string | null;
    userIds?: number[];
    createdBy?: string | null;
}

export interface CreateTaskListCommand {
    name?: string;
    description?: string | null;
    userId?: number;
}

export interface TaskDto {
    id?: number;
    title?: string;
    description?: string | null;
    isCompleted?: boolean;
    taskListId?: number;
    userIds?: number[];
    rank?: number;
    color?: string;
    isFavorite?: boolean;
    createdBy?: string | null;
    lastModified?: string | null;
    lastModifiedBy?: string | null;
}

export interface CreateTaskCommand {
    title?: string;
    description?: string | null;
    taskListId?: number;
    userId?: number;
    rank?: number;
    color?: string;
    isFavorite?: boolean;
}

export interface UpdateTaskListCommand {
    id?: number;
    name?: string | null;
    description?: string | null;
}

export interface UpdateTaskStatusCommand {
    id?: number;
    isCompleted?: boolean;
}

export interface TaskSummaryDto {
    totalTasks?: number;
    completedTasks?: number;
}

export interface UpdateTaskDetailsCommand {
    id?: number;
    rank?: number | null;
    color?: string | null;
    isFavorite?: boolean | null;
}

export interface UserDto {
    userId?: number;
    username?: string;
}

export interface CreateUpdateTemplateExampleCustomerDTO {
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
    address?: TemplateExampleAddressDTO;
}

export interface CreateTemplateExampleCustomerCommand extends CreateUpdateTemplateExampleCustomerDTO {
}

export interface TemplateExampleAddressDTO {
    street?: string;
    city?: string;
    state?: string;
    country?: string;
    zipCode?: string;
}

export interface UpdateTemplateExampleCustomerCommand extends CreateUpdateTemplateExampleCustomerDTO {
    id?: number;
}

export interface TemplateExampleDetailedCustomerDTO {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
    address?: TemplateExampleAddressDTO;
}

export interface TemplateExampleSimpleCustomerDTO {
    id?: number;
    firstName?: string;
    lastName?: string;
    email?: string;
    phone?: string;
}

export interface GetTemplateExampleCustomersQuery {
}

export interface CreateTemplateExampleItemCommand {
    name?: string;
    category?: string;
    description?: string;
    price?: number;
}

export interface UpdateTemplateExampleItemsStatusCommand {
    itemIds?: number[];
    status?: TemplateExampleItemStatus;
}

export enum TemplateExampleItemStatus {
    UnPublished = 0,
    Published = 1,
    SoldOut = 2,
    Recalled = 3,
    Discontinued = 4,
}

export interface TemplateExampleItemDTO {
    id?: number;
    name?: string;
    category?: string;
    description?: string;
    price?: number;
    status?: TemplateExampleItemStatus;
}

export interface CreateTemplateExampleOrderCommand {
    shippingAddress?: TemplateExampleAddressDTO;
    customerId?: number;
    items?: TemplateExampleOrderItemDTO[];
}

export interface TemplateExampleOrderItemDTO {
    itemId?: number;
    count?: number;
}

export interface TemplateExampleOrderDTO {
    id?: number;
    total?: number;
    shippingAddress?: TemplateExampleAddressDTO;
    status?: TemplateExampleOrderStatus;
    items?: TemplateExampleItemDTO2[];
    customer?: TemplateExampleCustomerDTO;
}

export enum TemplateExampleOrderStatus {
    Recieved = 0,
    Processing = 1,
    Shipped = 2,
    Delivered = 3,
    Completed = 4,
}

export interface TemplateExampleItemDTO2 {
    name?: string;
    category?: string;
    description?: string;
    price?: number;
}

export interface TemplateExampleCustomerDTO {
    firstName?: string;
    lastName?: string;
    address?: TemplateExampleAddressDTO;
}

export interface GetTemplateExampleOrdersQuery {
}

export interface RegisterUserCommand {
    username?: string;
    email?: string;
    password?: string;
}

export interface LoginResult {
    success?: boolean;
    error?: string | null;
    userId?: number;
    username?: string;
    token?: string;
}

export interface LoginUserQuery {
    username?: string;
    password?: string;
}

export enum CommandErrorCode {
    AspNetCoreCompatibleEmailValidator = 0,
    EmailValidator = 1,
    GreaterThanOrEqualValidator = 2,
    GreaterThanValidator = 3,
    LengthValidator = 4,
    MinimumLengthValidator = 5,
    MaximumLengthValidator = 6,
    LessThanOrEqualValidator = 7,
    LessThanValidator = 8,
    NotEmptyValidator = 9,
    NotEqualValidator = 10,
    NotNullValidator = 11,
    PredicateValidator = 12,
    AsyncPredicateValidator = 13,
    RegularExpressionValidator = 14,
    EqualValidator = 15,
    ExactLengthValidator = 16,
    InclusiveBetweenValidator = 17,
    ExclusiveBetweenValidator = 18,
    CreditCardValidator = 19,
    ScalePrecisionValidator = 20,
    EmptyValidator = 21,
    NullValidator = 22,
    EnumValidator = 23,
    TemplateExampleEmailInUse = 24,
    TemplateExampleEntityNotFound = 25,
}

export enum RoleEnum {
    Admin = 0,
    User = 1,
}

export enum Scope {
    UserRead = 0,
    UserWrite = 1,
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    throw new SwaggerException(message, status, response, headers, result);
}

/* istanbul ignore file */

/**
 * Used during client configuration.
 */

/**
 * Any public method are meant to be used after the individual client has been initialized
 */